\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{indentfirst} %Comment out for no first paragraph indent
\usepackage[parfill]{parskip}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{outlines}

\usepackage{fancyhdr}
\pagestyle{fancy}
\cfoot{\hyperlink{content}{\thepage}}
\lhead{}
\chead{}
\rfoot{}
\lfoot{}
\rhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}


\usepackage{hyperref}
\hypersetup {
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\newcommand{\sepitem}{0pt} %Added room between items on the list, not including a list and its sublist
\newcommand{\seppar}{1pt} %Between items and lists overall

\setenumerate[1]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[2]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[3]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[4]{itemsep=\sepitem, parsep=\seppar}

\newenvironment{outline*}
{
	\begin{outline}[enumerate]
	}
	{\end{outline}
}

\newcommand{\foot}[1]{\hyperlink{#1}{$_#1$}}

\begin{document}

\title{Computer Programming I}
\author{Avery Karlin}
\date{}
\newcommand{\textbook}{}
\newcommand{\teacher}{}

\maketitle
\newpage
\hypertarget{content}{\tableofcontents}
\vspace{11pt}
\noindent
\underline{Primary Textbook}: \textbook\\
\underline{Teacher}: \teacher
\newpage

\section{Introduction to OCaml}
\subsection{Program Design}
\begin{outline*}
\1 Programming can be viewed as the division into four steps, understanding the program, formalizing the interface, writing test cases, and implementing behavior
\2 The first involves finding any relevent concepts and how they relate to each other within the program, while the second determines input and output, and their respective formats
\2 The third determines the correct answer to standard cases, edge cases, and erroneous cases (in which the user is at fault) for how the program should behave, writing test cases in the program
\2 The fourth step is the programming, often taking recursive decompositions of the problem, dividing it by concept, the relationships between, and the interface to allow easier debugging
\end{outline*}
\subsection{Basic OCaml Programming}
\begin{outline*}
\1 OCaml supports integer (int), boolean (bool), and string (string) primitive/atomic types, able to be defined into expressions combining the types and operations on them, working by order of operations
\2 Basic operations on integers include +, -, *, /, mod, string\_of\_int (converting integer to string), on strings (surrounded by double-quotes) include \^ (concatenation), on booleans include not, \&\&, ||, and general comparisons include =, <> ),(inequality <, <=, >, >=
\1 Models of computation are ways of thinking about how a program executes, allowing prediction of its behavior, such as object or value oriented programming
\2 Value-oriented is the idea that running expressions reduces it to a value, rather than an action, such as input/output, as the basis of OCaml
\2 This is designated by the notation $<exp> => <val>$, called the evalutation of the expression by calculation as an abstract model of the computer calculation
\3 The internal steps are written out by $\|-> <intermediary exp>$ by order of operations
\1 If-then-else constructs, written ``if <exp> then <exp> else <exp>'', evaluating one of the last two based on the initial expression
\2 Since the constructs are expressions by themselves, the else is required since the construct expression needs a value if the expression is false
\1 OCaml programmings are made of declarations and commands, the former defining constants, functions, and expressions purely value oriented, the latter testing and generating output, non-value oriented
\2 The let declaration is written as ``let <id> = <exp>'', binding the identifier to the value, unable to be modified otherwise in the program
\3 It is often annotated by ``let <id> : <type> = <exp>'' for ease of reading, though this is not required
\3 Let declarations then automatically substitute each subsequent <id> with the value of the expression
\3 Redeclaring a variable is called shadowing, such that the each identifier is substituted by the nearest enclosing declaration, though this is not recommended, producing ambiguity
\4 Shadowing rather than redefining is apparent within the limited scope of some shadows, such that it reverts back to the original
\2 Let-in constructs are local declarations, written ``let <id> : <type> = <exp> in <exp>'' only using the decaration within the in expression
\3 This is able to be nested, such that each applies in the next which eventually all apply within a single expression
\2 Parameterized expressions/functions, declared by ``let <id> (<id1>:<type1>) (<id2>:<type2>) : <type> = <exp>'', called by ``<id> <val1> <val2>''
\3 This runs by substituting the function expression for the function call and the variable id into the function
\1 OCaml is strongly typed, such that each type is different with strict rules about combination or conversion, called well-typed if it has at least one type, able to be determined by the operations acting on it or the data
\2 The compiler automatically typechecks for ill-typed expressions which cannot be evaluated due to type contradictions
\3 Comparison operators return an error with two values of different types
\3 The compiler will also alert a missing argument or an extra argument to some function
\2 Functions use explicit type definition to improve clarity, abbreviating in the description the input types and the output type by ``<id> : <in1Type> -> <in2Type> -> ... -> <outType>''
\1 OCaml has the ``failwith <errorString>'', ending the program and printing the error message if the expression is evaluated
\1 Commands in OCaml are used for I/O, not calculating a value, but rather having some external effect, only able to be used in the top-level of a program, precluded by ``;;'' to distinguish commands
\2 ``print\_string <String>'' is used to print a string in output, ending the string by `\\n' for a newline, able to use an expression to evaluate to a string
\3 Similarly, ``print\_endline'' prints the string with an automatic newline, ``print\_int'' for an integer
\2 The ``run\_test'' command is stored in the Assert library, called by the ``open Assert'' command at the start, used by ``run\_test <descriptionString> <boolVal>''
\end{outline*}
\section{Lists and Recursion}
\begin{outline*}
\1 Lists are sequences of at least zero values, either [], the empty list/nil, or ``item1::item2::[]'' as the list of [item1, item2], able to compound to longer lists, where :: is the constructor operator for the list
\2 Lists of lists are also able to be created, and expressions can be used as items, evaluating to the value added to the list
\2 Lists are also able to be made by shorthand, ``[item1;item2]''
\2 List types are denoted by ``<primitiveType> list'', required to be a homogeneous/single-type list, such that double lists are denoted ``<primitiveType> list list'' and so forth
\2 OCaml is able to deconstruct expressions by pattern matching, written ``begin match <exp> with | <case> -> <return> ... end''
\3 Thus, for a list, the two cases to test for are ``[]'' and ``$<$var1$>$::$<$list1$>$'', checking for an empty list, such that if the latter case is found, the <var1> and <list1> identifiers are bound to the cooresponding list parts
\2 List concatnation is performed by the ``@'' operator
\1 Lists in OCaml are defined self-referentially, as an inductive data type, stating how to build an atomic instance, and construct a larger value out of it
\2 As a result, both calculations and creation of lists are done by structural recursion, using an empty list base case, calculating for the head assuming the tail has been calculated already
\3 This can be determined by writing out each new recursion to analyze how each level of recursion can be used to get the desired result
\2 Recursive functions in OCaml must be defined by ``let rec'' at the start instead of just ``let''
\2 OCaml does not ensure that all recursion is structural (taking a smaller portion of the structure towards the base case), providing the possibility for loops or an infinite loop
\end{outline*}
\section{Tuples and Nested Patterns}
\begin{outline*}
\1 Tuples store a set number of values (at least 2) of different types, able to use expressions or complex types, denoted generally as ``(<val1>, <val>2, ...>) : <type1> * <type2> ...''
\2 Pattern matching can be used similarly, though generally only needing a single case, due to only one form of construction
\3 Let constructions can also be used, written ``let ($<var1>, <var2>) = <var> in <var1/var2>$'' to set $<var>$ to either $<var1>$ or $<var2>$ for a two-item tuple
\3 Nested patterns of lists and tuples can also be combined for more complex pattern matching, testing the patterns in the order listed in the match statement
\3 If there is no match, it will return a Match\_Failure when run, such that it will give a non-exaustive pattern-matching warning during compilation
\3 In a pattern match, if a variable is not used, it can be replaced by \_ to act as a placeholder/wildcard for an unused value
\2 Empty tuples are represented by () with type of unit, used as the function paramter for functions without proper inputs, though able to be shorthanded as () in that case instead of (<var>: unit)
\3 It is also considered the return type for a command function, such that no output is produced
\end{outline*}
\section{User-defined Datatypes}
\begin{outline*}
\1 User-defined datatypes are needed to represent application specific types, used to avoid issues with primitives such as invalid values, confusion of types, and invalid default operations
\2 They are defined by ``type $<id> = | <val1> | <val2>$ ...'', where $<id>$ must be all lowercase, while each $<val>$ must start with an uppercase letter, each representing an atomic, discrete value
	\3 These are constructed purely by the <val>
\2 Types are also able to be represented as tuples of multiple datatypes, defined by ``type $<id> = | <val1> of <type1> | <val2> of <type2>$ ...''
	\3 These are constructed by ``$<val> (<type\_values>)$'', with more complicated match expressions
	\3 Similarly, type abbreviations can rename existing types, such that ``type $<id> = <type>$'', acting as a substitute for a general constructor name
\2 Types can be defined recursively as well, with some base case, with the other discrete values using the type itself
\end{outline*}
\section{Binary Trees}
\begin{outline*}
\1 Trees are used in CS either naturally or due to allowing ordering large amounts of data for efficient searching, defined recursively as either empty or a node
	\2 Root nodes are those at the top of the tree, leaf nodes at the bottom, internal nodes as all others, with each node having 0-2 child notes in a binary tree
	\2 Each node stores some value, and a link to each of its child nodes, but not its parent node, generally ``$<leftChild>, <val>, <rightChild>$''
	\2 Trees can be traversed by pre-order (left, right, node), in-order (left, node, right), post-order (left, right, node), able to be used to list items or search
\1 Trees can allow for easier searching if there are linearly ordered labels, such that binary search tree invarient are such that the right node being greater than, the left less than, Empty as the default, such that search is logarithmic
	\2 Binary search trees are constructed such that the nodes are inserted or deleted in accordance with the ordering
	\2 Inserting is similarly done to searching, while deleting requires a simple case for 0 children and 1 child, but for 2 children, the left maximum leaf replaces the deleted node and is removed from the bottom
\end{outline*}
\section{Generic Functions and Datatypes}
\begin{outline*}
\1 Generic functions are those where the type doesn't change the function, given type `<var>, where '<var> is the type variable, instantiated to any type by the function, but unable to be reassigned to a different type
	\2 This allows the reusing of functions and algorithms, saving time in both coding and debugging, rather than having large numbers of close to identical functions
	\2 Types can also be made generically, written ``type ('$<var1>, '<var2>) <id>$'', such that they can be generalized to being made up of any type components, able to be computed by generic pattern matching
\end{outline*}
\section{First-class Functions}
\begin{outline*}
\1 Since functions are values in value-oriented programming such as OCaml, functions are able to used as parameters for other functions and returned by functions, called the first-order function characteristic
	\2 As a result, functions can also be partially applied, giving only a portion of the inputs, such that it returns a function with that variable filled
	\2 Anonymous functions are those without a name, written by the keyword fun, with syntax ``fun $(<var1>:<type1>) (<var2>:<type2>) -> <exp>$'', acting as values
		\3 These are able to be bound by a let expression, ``let $<funName> : <type1> -> <type2> -> <retType> = <anonFunction>$'', equivelent to a standard function form
\1 As a result, first order functions are able to be combined with generics to produce higher order functions, which are more generalized functions, taking a function and applying it to some generic object
	\2 Common examples of this are used to transform a list by some function or to fold a list by some combine function and a base case into a single object
\1 Partial functions with option types are those which do not always find a value, used for those that require specific inputs to return a proper output, using an option type to return a null option if no value is possible, and a value storage option otherwise
\end{outline*}
\section{Modularity and Abstraction}
\begin{outline*}
\1 Abstract types are those which bundle the operations and type name with an interface for the functions by which it can be used, but do not allow direct access to the implementation/proper function codes
	\2 Modules are independently compilable collections of code, containing abstract data types and their functions, which when providing common data structures or algorithms, are called libraries
		\3 These are accessed either by ``;; open $<Module>$'' or by using dot notation for any identifiers given by the module ($<Module>.<Id>$)
	\2 Interfaces are created either in an mli file type or a module type signature, the former written by the type name, followed by each function written by ``val $<functName> : <input1> -> <input2> -> <output>$'', where val is used to denote an expected value
		\3 Module type signatures are written inside an ml file by ``module type $<typeName> = sig <typeInterface>$ end'', with the interface written as in an mli file
		\3 The implementation can be written as a module of the interface as a nonabstract type, by ``module $<typeName> : <AbstractTypeName> = struct <typeImplementation>$ end'', called an explicitly named module
			\4 In this case, the ml file in which they are defined must be opened, after which dot notation must be used for each type, rather than either
	\2 For each implementation, OCaml checks if it fully complies with the interface, implementing all expected functions, though it is able to have additional ones
\1 Abstract types are useful for not showing the specific usage of implementation, allowing any particular means of implementing, using some implementation type combined with an invarient/rule to preserve the type properties
	\2 Each choice of representation and invariant has respective advantages and disadvantages in terms of time optimization
\end{outline*}
\section{Unit and Sequencing Commands}
\begin{outline*}
\1 Functions are able to take or return unit variables in cases in which the parameter/return type are irrelevent, used by commands to represent the external effect produced
	\2 Thus, ``print\_string'' and other similar commands return a unit type
\1 Commands can be embeded in an expression using a single operator, ``;'', between the command and the next portion of the expression, returning a unit value which is ignored, but which may have side effects within the program
	\2 As a result, the semicolon is always used as a separator, rather than as a terminator like in many other languages, seperating commands, fields, elements, or running top-level commands
\end{outline*}
\section{Mutability and Abstract Stack Machine}
\begin{outline*}
\1 Records assign names to specific values, such that they is defined by ``type $<name>$ = \{$<name1>:<type1>; ...$<nameN> = <valN>$;\}$'', with records written by ``let $<var>: <name> = \{<name1> = <val1>$; ...$<nameN> = <valN>$\}''
	\2 Values are accessed by ``$<var>.<nameNumber>$'', able to be changed slightly in a new variable by ``let $<newVar> = \{<var> with <nameNumber1>=<valNumber1>; ...\}$''
	\2 Existing records can be copied and modified by ``\{$<oldRecord> with <nameNumberN> = <valNumberN>$\}''
\1 Mutable data are those which are able to be properly changed, rather than shadowed, destroying the original data, called imperative programming rather than pure programming, allowing aspects of the program to share data elements
	\2 Mutable records are defined by ``type $<name> = \{mutable <name1> : <type1>\}$'', able to be defined outside of a function as a global variable
	\2 These are changed by ``$<var> <- <newVal>$;'', acting as a command returning a unit
	\2 Due to mutable values being shared by functions, multiple variables are able to point to the same data structures, called aliasing, destroying the substitution programming simplification method
	\2 Programs using mutable data are refeerred to as imperative programming, while those that don't are pure programming
\1 The Abstract Stack Machine is an alternative to the substitution model, accounting for the location of data in the computer memory, assuming the language is type-safe and garbage-collected, such as OCaml or Java
	\2 It is made up of the workspace to keep track of the expression currently being evalutated, the stack for bindings, primitive values, and partially simplified expressions, and the heap is for data structures
		\3 Bindings are made up of an identifier and a reference to an address/location of a piece of data, denoted by an arrow
			\4 References are abstract locations, not having a specific value within the computer, while pointers are the specific reference location value
		\3 The heap contains cells (labelled data types with possible parameters/references), records (containing a table with the variables on the left, the values double boxed on the right), and anonymous functions
	\2 The ASM begins with an empty stack and heap, finding the left-most ready expression within the workspace to simplify, adding to the stack and heap as it moves along, removing those expressions from the workspace
		\3 Each value is added below previous values in the stack, using the most recent value within the stack at a given time to display shadowing
		\3 The stack functions by popping out all elements from the bottom as it leaves the scope, such that it follows the LIFO procedure
		\3 The evaluation of the expression is complete when the result is the remaining item in the workspace
		\3 Function definitions are converted to an anonymous function with a binding, the binding put in the stack, and the anonymous function placed in the heap
	\2 Functions are simplified by adding the outside layer of the function into the stack with a space inside for the result of the inner layers, changing the inner layer into the new workspace, evaluating, then bringing it back to the workspace and popping off the stack for the inner layer
		\3 The space inside the outer function layer is denoted by ``(\_\_\_)''
	\2 Aliases are denoted by references in the stack to the same object in the heap, tested by the reference equality operator ``=='', rather than the structural equality ``=''
		\3 For primitive values, since they are only in the stack, the reference equality operator returns true if the structural equality operator does
\1 Options are denoted about the value with an arrow at the top left corner, while a slash through the reference box implies it links to a None option
\end{outline*}
\section{Queues/Linked Structures}
\begin{outline*}
\1 Linked structures are made out of a data block attached to other data blocks in some sequence with some set of operations able to act on it
	\2 Queues are structures with the function enqueue to add to the tail, and dequeue to remove from the head, with last in, last out (LILO) usage, with each node made up of a value and a mutable option link to the next value
	\2 The queue also contains a link to the first and last non-zero elements within the queue
\1 The Queue Invariant states that either the head and tail must both be None, or for the head as Some n1 and the tail as Some n2, n2 is reachable by following next pointers from n1 and n2.next is None
	\2 As a result, the same node is not able to be in the queue more than once as an alias, due to violating the invariant by creating a cycle
\1 Mutable structures can be evaluated by a loop helper function defined within the overall function, either by recursion or by tail call optimization
	\2 Tail call optimization saves space by modifying recursion into iteration, emptying the workspace of the previous function call fully before calling it again, such that the bindings can be removed from the stack
		\3 As a result, the final call within the recursive function is the calling of it again, having fully evaluated the previous call, using an accumulation argument to preserve values from previous calls
	\2 This provides more risk of undetected infinite loops, due to not causing a stack overflow, either by not iterating through the structure or iterating through a cycle
\end{outline*}
\section{Local State/Objects}
\begin{outline*}
\1 Local states are states packaged with several functions that operate on it, shared mutably between the functions, unable to be modified outside of those functions, used to avoid the need for many global states
	\2 Rather than a global record to keep track of a state, there is a function producing a new record each time it is run, returning a function to increment that counter
	\2 This is accomplished by the ASM storing the function, along with any local stack bindings needed to evaluate it, to the heap, such that the counter isn't on the stack, but is readded by the function immediately when called, even before arguments are added to the stack
	\2 The combination of a function and locally stored bindings is called a closure, with the localization of the state being called encapsulation, restricting access to the data to the specifically designated functions
		\3 Multiple objects are also able to be tied to the same data, to allow separation between the modification functions and the usage functions
\1 Objects are created by making a record of several functions, and a creation function that produces a state record modified by the function records
	\2 This is made easier by the 'a ref (reference) type, used as shorthand for a record with a single mutable field called contents, with the ! operator to provide the contents, and the := operator to redefine the contents
\end{outline*}
\section{OCaml GUI Library}
\begin{outline*}
\1 GUIs use an event-driven model of reactive programming, reacting to user-caused events, such as mouse or keyboard input
	\2 OCaml uses the event type, as a record to indicate the status of keys, the mouse button, and the mouse location
\1 The OCaml graphic library is used by adding the ``graphics.cma'' compiler flag, providing functions such as open\_graph (to open a new window), clear\_graph (to erase the window), resize\_window (to set the window size), size\_x (to return the width), and size\_y (to return the height)
	\2 It also provides the type color, as a record with items r, g, and b, with various predefined colors
	\2 It also contains a pen with functions set\_color, move\_to, and (plot x y) to color the pixel with the current pen color, as well as (line\_to x y) (from the current location) and functions for other shapes drawn
	\2 The graphics library uses double buffering, modifying a hidden second copy of the window, pushing that into the main window and erasing, instead of modifying the main window directly to prevent flickering
\1 GUI libraries are generally made with built-in buttons and textboxes, as well as systems for positioning relative components of the GUI, to avoid precarious global window coordinate systems
	 \2 Widgets are made such that they generate themselves using a widget-local coordinate system, with the left upper corner as the origin, offset by the main window
	 	\3 As a result, there is the Gctx module used to draw the widget, with the gctx type including the color and location, used to get the offset, all from the upper left hand corner, as well as including methods to convert from coordinate systems
	 		\4 Gctx also has functions used to draw different objects
	 	\3 The OCaml graphics library has the origin at the lower left corner, rather than the upper, which is non-ideal for a GUI, due to adding space to the bottom, rather than the top
	 \2 The widget module is a closure containing a repaint function (using a gctx coordinate) and a size function, including a space widget, a label widget, a canvas (parameterized drawing) widget, and a border widget (taking another as a parameter)
	 	\3 The hpair function is used to pair two widgets into a single widget, aligned at the top, equally next to each other, and a border widget, padding the outside of a widget into a larger widget, connected to the original widgets
	 	\3 This allows forming a widget tree to create a complete widget appearance, generating a complete widget, with the base as the highest level/toplevel
\1 GUIs are generated by creating an infinite loop run function, repainting the entire GUI with any changes constantly, waiting for an event, then called the handle function of the root widget
	\2 Event types are mouse drags, moves, up, and down (returning the type and position), as well as key presses (returning the character pressed)
	\2 Event handlers of a widget take in the graphics state (gctx) and the event, routing through the widget tree to the final widget
		\3 Notifier widgets are used to check for events, keeping a list of event listeners, sending the event to each event listener, which in turn performs an action function if the event is detected
	\2 Widgets which have states also have controller objects to control the state, routing to the same local state
		\3 The controller object might also have a list of change listeners, modifying those values based on the new object value
\end{outline*}
\section{Homework Notes}
\begin{outline*}
\1 No multi command conditionals?
\1 In needed for complex functions?
\1 Can't create an empty user-defined datatype, accessed by begin match similar to regular types (Node (a, b) ->, etc)
\1 Need either variable or wildcard
\1 When can you use multiple lines in a single begin match command?
\1 Type is not properly implemented in interface, though a function for an empty can be, since functions are values in OCaml
\1 Equals checks if the structure is identical, in addition to the data for any object

\1 Dot library notation can be used rather than including the library directly
\end{outline*}
\end{document}