\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{indentfirst} %Comment out for no first paragraph indent
\usepackage[parfill]{parskip}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{outlines}

\usepackage{fancyhdr}
\pagestyle{fancy}
\cfoot{\hyperlink{content}{\thepage}}
\lhead{}
\chead{}
\rfoot{}
\lfoot{}
\rhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}


\usepackage{hyperref}
\hypersetup {
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\newcommand{\sepitem}{0pt} %Added room between items on the list, not including a list and its sublist
\newcommand{\seppar}{1pt} %Between items and lists overall

\setenumerate[1]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[2]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[3]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[4]{itemsep=\sepitem, parsep=\seppar}

\newenvironment{outline*}
{
	\begin{outline}[enumerate]
	}
	{\end{outline}
}

\newcommand{\foot}[1]{\hyperlink{#1}{$_#1$}}

\begin{document}

\title{Computer Programming I}
\author{Avery Karlin}
\date{}
\newcommand{\textbook}{}
\newcommand{\teacher}{}

\maketitle
\newpage
\hypertarget{content}{\tableofcontents}
\vspace{11pt}
\noindent
\underline{Primary Textbook}: \textbook\\
\underline{Teacher}: \teacher
\newpage

\section{Introduction to OCaml}
\subsection{Program Design}
\begin{outline*}
\1 Programming can be viewed as the division into four steps, understanding the program, formalizing the interface, writing test cases, and implementing behavior
\2 The first involves finding any relevent concepts and how they relate to each other within the program, while the second determines input and output, and their respective formats
\2 The third determines the correct answer to standard cases, edge cases, and erroneous cases (in which the user is at fault) for how the program should behave, writing test cases in the program
\2 The fourth step is the programming, often taking recursive decompositions of the problem, dividing it by concept, the relationships between, and the interface to allow easier debugging
\end{outline*}
\subsection{Basic OCaml Programming}
\begin{outline*}
\1 OCaml supports integer (int), boolean (bool), and string (string) primitive/atomic types, able to be defined into expressions combining the types and operations on them, working by order of operations
\2 Basic operations on integers include +, -, *, /, mod, string\_of\_int (converting integer to string), on strings (surrounded by double-quotes) include \^ (concatenation), on booleans include not, \&\&, ||, and general comparisons include =, <> (inequality), <, <=, >, >=
\1 Models of computation are ways of thinking about how a program executes, allowing prediction of its behavior, such as object or value oriented programming
\2 Value-oriented is the idea that running expressions reduces it to a value, rather than an action, such as input/output, as the basis of OCaml
\2 This is designated by the notation $<exp> => <val>$, called the evalutation of the expression by calculation as an abstract model of the computer calculation
\3 The internal steps are written out by $\|-> <intermediary exp>$ by order of operations
\1 If-then-else constructs, written ``if <exp> then <exp> else <exp>'', evaluating one of the last two based on the initial expression
\2 Since the constructs are expressions by themselves, the else is required since the construct expression needs a value if the expression is false
\1 OCaml programmings are made of declarations and commands, the former defining constants, functions, and expressions purely value oriented, the latter testing and generating output, non-value oriented
\2 The let declaration is written as ``let <id> = <exp>'', binding the identifier to the value, unable to be modified otherwise in the program
\3 It is often annotated by ``let <id> : <type> = <exp>'' for ease of reading, though this is not required
\3 Let declarations then automatically substitute each subsequent <id> with the value of the expression
\3 Redeclaring a variable is called shadowing, such that the each identifier is substituted by the nearest enclosing declaration, though this is not recommended, producing ambiguity
\4 Shadowing rather than redefining is apparent within the limited scope of some shadows, such that it reverts back to the original
\2 Let-in constructs are local declarations, written ``let <id> : <type> = <exp> in <exp>'' only using the decaration within the in expression
\3 This is able to be nested, such that each applies in the next which eventually all apply within a single expression
\2 Parameterized expressions/functions, declared by ``let <id> (<id1>:<type1>) (<id2>:<type2>) : <type> = <exp>'', called by ``<id> <val1> <val2>''
\3 This runs by substituting the function expression for the function call and the variable id into the function
\1 OCaml is strongly typed, such that each type is different with strict rules about combination or conversion, called well-typed if it has at least one type, able to be determined by the operations acting on it or the data
\2 The compiler automatically typechecks for ill-typed expressions which cannot be evaluated due to type contradictions
\3 Comparison operators return an error with two values of different types
\3 The compiler will also alert a missing argument or an extra argument to some function
\2 Functions use explicit type definition to improve clarity, abbreviating in the description the input types and the output type by ``<id> : <in1Type> -> <in2Type> -> ... -> <outType>''
\1 OCaml has the ``failwith <errorString>'', ending the program and printing the error message if the expression is evaluated
\1 Commands in OCaml are used for I/O, not calculating a value, but rather having some external effect, only able to be used in the top-level of a program, precluded by ``;;'' to distinguish commands
\2 ``print\_string <String>'' is used to print a string in output, ending the string by `\\n' for a newline, able to use an expression to evaluate to a string
\3 Similarly, ``print\_endline'' prints the string with an automatic newline, ``print\_int'' for an integer
\2 The ``run\_test'' command is stored in the Assert library, called by the ``open Assert'' command at the start, used by ``run\_test <descriptionString> <boolVal>''
\end{outline*}
\section{Lists and Recursion}
\begin{outline*}
\1 Lists are sequences of at least zero values, either [], the empty list/nil, or ``item1::item2::[]'' as the list of [item1, item2], able to compound to longer lists, where :: is the constructor operator for the list
\2 Lists of lists are also able to be created, and expressions can be used as items, evaluating to the value added to the list
\2 Lists are also able to be made by shorthand, ``[item1;item2]''
\2 List types are denoted by ``<primitiveType> list'', required to be a homogeneous/single-type list, such that double lists are denoted ``<primitiveType> list list'' and so forth
\2 OCaml is able to deconstruct expressions by pattern matching, written ``begin match <exp> with | <case> -> <return> ... end''
\3 Thus, for a list, the two cases to test for are ``[]'' and ``$<$var1$>$::$<$list1$>$'', checking for an empty list, such that if the latter case is found, the <var1> and <list1> identifiers are bound to the cooresponding list parts
\2 List concatnation is performed by the ``@'' operator
\1 Lists in OCaml are defined self-referentially, as an inductive data type, stating how to build an atomic instance, and construct a larger value out of it
\2 As a result, both calculations and creation of lists are done by structural recursion, using an empty list base case, calculating for the head assuming the tail has been calculated already
\3 This can be determined by writing out each new recursion to analyze how each level of recursion can be used to get the desired result
\2 Recursive functions in OCaml must be defined by ``let rec'' at the start instead of just ``let''
\2 OCaml does not ensure that all recursion is structural (taking a smaller portion of the structure towards the base case), providing the possibility for loops or an infinite loop
\end{outline*}
\section{Tuples and Nested Patterns}
\begin{outline*}
\1 Tuples store a set number of values (at least 2) of different types, able to use expressions or complex types, denoted generally as ``(<val1>, <val>2, ...>) : <type1> * <type2> ...''
\2 Pattern matching can be used similarly, though generally only needing a single case, due to only one form of construction
\3 Let constructions can also be used, written ``let ($<var1>, <var2>) = <var> in <var1/var2>$'' to set $<var>$ to either $<var1>$ or $<var2>$ for a two-item tuple
\3 Nested patterns of lists and tuples can also be combined for more complex pattern matching, testing the patterns in the order listed in the match statement
\3 If there is no match, it will return a Match\_Failure when run, such that it will give a non-exaustive pattern-matching warning during compilation
\3 In a pattern match, if a variable is not used, it can be replaced by \_ to act as a placeholder/wildcard for an unused value
\2 Empty tuples are represented by () with type of unit, used as the function paramter for functions without proper inputs, though able to be shorthanded as () in that case instead of (<var>: unit)
\3 It is also considered the return type for a command function, such that no output is produced
\end{outline*}
\section{User-defined Datatypes}
\begin{outline*}
\1 User-defined datatypes are needed to represent application specific types, used to avoid issues with primitives such as invalid values, confusion of types, and invalid default operations
\2 They are defined by ``type $<id> = | <val1> | <val2>$ ...'', where $<id>$ must be all lowercase, while each $<val>$ must start with an uppercase letter, each representing an atomic, discrete value
	\3 These are constructed purely by the <val>
\2 Types are also able to be represented as tuples of multiple datatypes, defined by ``type $<id> = | <val1> of <type1> | <val2> of <type2>$ ...''
	\3 These are constructed by ``$<val> (<type\_values>)$'', with more complicated match expressions
	\3 Similarly, type abbreviations can rename existing types, such that ``type $<id> = <type>$'', acting as a substitute for a general constructor name
\2 Types can be defined recursively as well, with some base case, with the other discrete values using the type itself
\end{outline*}
\section{Binary Trees}
\begin{outline*}
\1 Trees are used in CS either naturally or due to allowing ordering large amounts of data for efficient searching, defined recursively as either empty or a node
	\2 Root nodes are those at the top of the tree, leaf nodes at the bottom, internal nodes as all others, with each node having 0-2 child notes in a binary tree
	\2 Each node stores some value, and a link to each of its child nodes, but not its parent node, generally ``$<leftChild>, <val>, <rightChild>$''
	\2 Trees can be traversed by pre-order (left, right, node), in-order (left, node, right), post-order (left, right, node), able to be used to list items or search
\1 Trees can allow for easier searching if there are linearly ordered labels, such that binary search tree invarient are such that the right node being greater than, the left less than, Empty as the default, such that search is logarithmic
	\2 Binary search trees are constructed such that the nodes are inserted or deleted in accordance with the ordering
	\2 Inserting is similarly done to searching, while deleting requires a simple case for 0 children and 1 child, but for 2 children, the left maximum leaf replaces the deleted node and is removed from the bottom
\end{outline*}
\section{Generic Functions and Datatypes}
\begin{outline*}
\1 Generic functions are those where the type doesn't change the function, given type `<var>, where '<var> is the type variable, instantiated to any type by the function, but unable to be reassigned to a different type
	\2 This allows the reusing of functions and algorithms, saving time in both coding and debugging, rather than having large numbers of close to identical functions
	\2 Types can also be made generically, written ``type ('$<var1>, '<var2>) <id>$'', such that they can be generalized to being made up of any type components, able to be computed by generic pattern matching
\end{outline*}
\section{First-class Functions}
\begin{outline*}
\1 Since functions are values in value-oriented programming such as OCaml, functions are able to used as parameters for other functions and returned by functions, called the first-order function characteristic
	\2 As a result, functions can also be partially applied, giving only a portion of the inputs, such that it returns a function with that variable filled
	\2 Anonymous functions are those without a name, written by the keyword fun, with syntax ``fun $(<var1>:<type1>) (<var2>:<type2>) -> <exp>$'', acting as values
		\3 These are able to be bound by a let expression, ``let $<funName> : <type1> -> <type2> -> <retType> = <anonFunction>$'', equivelent to a standard function form
\1 As a result, first order functions are able to be combined with generics to produce higher order functions, which are more generalized functions, taking a function and applying it to some generic object
	\2 Common examples of this are used to transform a list by some function or to fold a list by some combine function and a base case into a single object
\end{outline*}
\section{Modularity and Abstraction}
\begin{outline*}
\1 Abstract types are those which bundle the operations and type name with an interface for the functions by which it can be used, but do not allow direct access to the implementation/proper function codes
	\2 Modules are independently compilable collections of code, containing abstract data types and their functions, which when providing common data structures or algorithms, are called libraries
		\3 These are accessed either by ``;; open $<Module>$'' or by using dot notation for any identifiers given by the module ($<Module>.<Id>$)
	\2 Interfaces are created either in an mli file type or a module type signature, the former written by the type name, followed by each function written by ``val $<functName> : <input1> -> <input2> -> <output>$'', where val is used to denote an expected value
		\3 Module type signatures are written inside an ml file by ``module type $<typeName> = sig <typeInterface>$ end'', with the interface written as in an mli file
		\3 The implementation can be written as a module of the interface as a nonabstract type, by ``module $<typeName> : <AbstractTypeName> = struct <typeImplementation>$ end'', called an explicitly named module
			\4 In this case, the ml file in which they are defined must be opened, after which dot notation must be used for each type, rather than either
	\2 For each implementation, OCaml checks if it fully complies with the interface, implementing all expected functions, though it is able to have additional ones
\1 Abstract types are useful for not showing the specific usage of implementation, allowing any particular means of implementing, using some implementation type combined with an invarient/rule to preserve the type properties
	\2 Each choice of representation and invariant has respective advantages and disadvantages in terms of time optimization
\end{outline*}
\section{Homework Notes}
\begin{outline*}
\1 No multi command conditionals?
\1 In needed for complex functions?
\1 Can't create an empty user-defined datatype, accessed by begin match similar to regular types (Node (a, b) ->, etc)
\1 Need either variable or wildcard
\1 When can you use multiple lines in a single begin match command?
\1 Type is not properly implemented in interface, though a function for an empty can be, since functions are values in OCaml
\1 Equals checks if the structure is identical, in addition to the data for any object
\end{outline*}
\end{document}