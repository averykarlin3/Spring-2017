\documentclass[11 pt, twoside]{article}
\usepackage{textcomp}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{indentfirst} %Comment out for no first paragraph indent
\usepackage[parfill]{parskip}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{outlines}

\usepackage{fancyhdr}
\pagestyle{fancy}
\cfoot{\hyperlink{content}{\thepage}}
\lhead{}
\chead{}
\rfoot{}
\lfoot{}
\rhead{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}


\usepackage{hyperref}
\hypersetup {
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\newcommand{\sepitem}{0pt} %Added room between items on the list, not including a list and its sublist
\newcommand{\seppar}{1pt} %Between items and lists overall

\setenumerate[1]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[2]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[3]{itemsep=\sepitem, parsep=\seppar}
\setenumerate[4]{itemsep=\sepitem, parsep=\seppar}

\newenvironment{outline*}
{
	\begin{outline}[enumerate]
	}
	{\end{outline}
}

\newcommand{\foot}[1]{\hyperlink{#1}{$_#1$}}

\begin{document}

\title{Computer Programming I}
\author{Avery Karlin}
\date{}
\newcommand{\textbook}{}
\newcommand{\teacher}{}

\maketitle
\newpage
\hypertarget{content}{\tableofcontents}
\vspace{11pt}
\noindent
\underline{Primary Textbook}: \textbook\\
\underline{Teacher}: \teacher
\newpage

\section{Introduction to OCaml}
\subsection{Program Design}
\begin{outline*}
\1 Programming can be viewed as the division into four steps, understanding the program, formalizing the interface, writing test cases, and implementing behavior
\2 The first involves finding any relevent concepts and how they relate to each other within the program, while the second determines input and output, and their respective formats
\2 The third determines the correct answer to standard cases, edge cases, and erroneous cases (in which the user is at fault) for how the program should behave, writing test cases in the program
\2 The fourth step is the programming, often taking recursive decompositions of the problem, dividing it by concept, the relationships between, and the interface to allow easier debugging
\end{outline*}
\subsection{Basic OCaml Programming}
\begin{outline*}
\1 OCaml supports integer (int), boolean (bool), and string (string) primitive/atomic types, able to be defined into expressions combining the types and operations on them, working by order of operations
\2 Basic operations on integers include +, -, *, /, mod, string\_of\_int (converting integer to string), on strings (surrounded by double-quotes) include \^ (concatenation), on booleans include not, \&\&, ||, and general comparisons include =, <> ),(inequality <, <=, >, >=
\1 Models of computation are ways of thinking about how a program executes, allowing prediction of its behavior, such as object or value oriented programming
\2 Value-oriented is the idea that running expressions reduces it to a value, rather than an action, such as input/output, as the basis of OCaml
\2 This is designated by the notation $<exp> => <val>$, called the evalutation of the expression by calculation as an abstract model of the computer calculation
\3 The internal steps are written out by $\|-> <intermediary exp>$ by order of operations
\1 If-then-else constructs, written ``if <exp> then <exp> else <exp>'', evaluating one of the last two based on the initial expression
\2 Since the constructs are expressions by themselves, the else is required since the construct expression needs a value if the expression is false
\1 OCaml programmings are made of declarations and commands, the former defining constants, functions, and expressions purely value oriented, the latter testing and generating output, non-value oriented
\2 The let declaration is written as ``let <id> = <exp>'', binding the identifier to the value, unable to be modified otherwise in the program
\3 It is often annotated by ``let <id> : <type> = <exp>'' for ease of reading, though this is not required
\3 Let declarations then automatically substitute each subsequent <id> with the value of the expression
\3 Redeclaring a variable is called shadowing, such that the each identifier is substituted by the nearest enclosing declaration, though this is not recommended, producing ambiguity
\4 Shadowing rather than redefining is apparent within the limited scope of some shadows, such that it reverts back to the original
\2 Let-in constructs are local declarations, written ``let <id> : <type> = <exp> in <exp>'' only using the decaration within the in expression
\3 This is able to be nested, such that each applies in the next which eventually all apply within a single expression
\2 Parameterized expressions/functions, declared by ``let <id> (<id1>:<type1>) (<id2>:<type2>) : <type> = <exp>'', called by ``<id> <val1> <val2>''
\3 This runs by substituting the function expression for the function call and the variable id into the function
\1 OCaml is strongly typed, such that each type is different with strict rules about combination or conversion, called well-typed if it has at least one type, able to be determined by the operations acting on it or the data
\2 The compiler automatically typechecks for ill-typed expressions which cannot be evaluated due to type contradictions
\3 Comparison operators return an error with two values of different types
\3 The compiler will also alert a missing argument or an extra argument to some function
\2 Functions use explicit type definition to improve clarity, abbreviating in the description the input types and the output type by ``<id> : <in1Type> -> <in2Type> -> ... -> <outType>''
\1 OCaml has the ``failwith <errorString>'', ending the program and printing the error message if the expression is evaluated
\1 Commands in OCaml are used for I/O, not calculating a value, but rather having some external effect, only able to be used in the top-level of a program, precluded by ``;;'' to distinguish commands
\2 ``print\_string <String>'' is used to print a string in output, ending the string by `\\n' for a newline, able to use an expression to evaluate to a string
\3 Similarly, ``print\_endline'' prints the string with an automatic newline, ``print\_int'' for an integer
\2 The ``run\_test'' command is stored in the Assert library, called by the ``open Assert'' command at the start, used by ``run\_test <descriptionString> <boolVal>''
\end{outline*}
\section{Lists and Recursion}
\begin{outline*}
\1 Lists are sequences of at least zero values, either [], the empty list/nil, or ``item1::item2::[]'' as the list of [item1, item2], able to compound to longer lists, where :: is the constructor operator for the list
\2 Lists of lists are also able to be created, and expressions can be used as items, evaluating to the value added to the list
\2 Lists are also able to be made by shorthand, ``[item1;item2]''
\2 List types are denoted by ``<primitiveType> list'', required to be a homogeneous/single-type list, such that double lists are denoted ``<primitiveType> list list'' and so forth
\2 OCaml is able to deconstruct expressions by pattern matching, written ``begin match <exp> with | <case> -> <return> ... end''
\3 Thus, for a list, the two cases to test for are ``[]'' and ``$<$var1$>$::$<$list1$>$'', checking for an empty list, such that if the latter case is found, the <var1> and <list1> identifiers are bound to the cooresponding list parts
\2 List concatnation is performed by the ``@'' operator
\1 Lists in OCaml are defined self-referentially, as an inductive data type, stating how to build an atomic instance, and construct a larger value out of it
\2 As a result, both calculations and creation of lists are done by structural recursion, using an empty list base case, calculating for the head assuming the tail has been calculated already
\3 This can be determined by writing out each new recursion to analyze how each level of recursion can be used to get the desired result
\2 Recursive functions in OCaml must be defined by ``let rec'' at the start instead of just ``let''
\2 OCaml does not ensure that all recursion is structural (taking a smaller portion of the structure towards the base case), providing the possibility for loops or an infinite loop
\end{outline*}
\section{Tuples and Nested Patterns}
\begin{outline*}
\1 Tuples store a set number of values (at least 2) of different types, able to use expressions or complex types, denoted generally as ``(<val1>, <val>2, ...>) : <type1> * <type2> ...''
\2 Pattern matching can be used similarly, though generally only needing a single case, due to only one form of construction
\3 Let constructions can also be used, written ``let ($<var1>, <var2>) = <var> in <var1/var2>$'' to set $<var>$ to either $<var1>$ or $<var2>$ for a two-item tuple
\3 Nested patterns of lists and tuples can also be combined for more complex pattern matching, testing the patterns in the order listed in the match statement
\3 If there is no match, it will return a Match\_Failure when run, such that it will give a non-exaustive pattern-matching warning during compilation
\3 In a pattern match, if a variable is not used, it can be replaced by \_ to act as a placeholder/wildcard for an unused value
\2 Empty tuples are represented by () with type of unit, used as the function paramter for functions without proper inputs, though able to be shorthanded as () in that case instead of (<var>: unit)
\3 It is also considered the return type for a command function, such that no output is produced
\end{outline*}
\section{User-defined Datatypes}
\begin{outline*}
\1 User-defined datatypes are needed to represent application specific types, used to avoid issues with primitives such as invalid values, confusion of types, and invalid default operations
\2 They are defined by ``type $<id> = | <val1> | <val2>$ ...'', where $<id>$ must be all lowercase, while each $<val>$ must start with an uppercase letter, each representing an atomic, discrete value
	\3 These are constructed purely by the <val>
\2 Types are also able to be represented as tuples of multiple datatypes, defined by ``type $<id> = | <val1> of <type1> | <val2> of <type2>$ ...''
	\3 These are constructed by ``$<val> (<type\_values>)$'', with more complicated match expressions
	\3 Similarly, type abbreviations can rename existing types, such that ``type $<id> = <type>$'', acting as a substitute for a general constructor name
\2 Types can be defined recursively as well, with some base case, with the other discrete values using the type itself
\end{outline*}
\section{Binary Trees}
\begin{outline*}
\1 Trees are used in CS either naturally or due to allowing ordering large amounts of data for efficient searching, defined recursively as either empty or a node
	\2 Root nodes are those at the top of the tree, leaf nodes at the bottom, internal nodes as all others, with each node having 0-2 child notes in a binary tree
	\2 Each node stores some value, and a link to each of its child nodes, but not its parent node, generally ``$<leftChild>, <val>, <rightChild>$''
	\2 Trees can be traversed by pre-order (left, right, node), in-order (left, node, right), post-order (left, right, node), able to be used to list items or search
\1 Trees can allow for easier searching if there are linearly ordered labels, such that binary search tree invarient are such that the right node being greater than, the left less than, Empty as the default, such that search is logarithmic
	\2 Binary search trees are constructed such that the nodes are inserted or deleted in accordance with the ordering
	\2 Inserting is similarly done to searching, while deleting requires a simple case for 0 children and 1 child, but for 2 children, the left maximum leaf replaces the deleted node and is removed from the bottom
\end{outline*}
\section{Generic Functions and Datatypes}
\begin{outline*}
\1 Generic functions are those where the type doesn't change the function, given type `<var>, where '<var> is the type variable, instantiated to any type by the function, but unable to be reassigned to a different type
	\2 This allows the reusing of functions and algorithms, saving time in both coding and debugging, rather than having large numbers of close to identical functions
	\2 Types can also be made generically, written ``type ('$<var1>, '<var2>) <id>$'', such that they can be generalized to being made up of any type components, able to be computed by generic pattern matching
\end{outline*}
\section{First-class Functions}
\begin{outline*}
\1 Since functions are values in value-oriented programming such as OCaml, functions are able to used as parameters for other functions and returned by functions, called the first-order function characteristic
	\2 As a result, functions can also be partially applied, giving only a portion of the inputs, such that it returns a function with that variable filled
	\2 Anonymous functions are those without a name, written by the keyword fun, with syntax ``fun $(<var1>:<type1>) (<var2>:<type2>) -> <exp>$'', acting as values
		\3 These are able to be bound by a let expression, ``let $<funName> : <type1> -> <type2> -> <retType> = <anonFunction>$'', equivelent to a standard function form
\1 As a result, first order functions are able to be combined with generics to produce higher order functions, which are more generalized functions, taking a function and applying it to some generic object
	\2 Common examples of this are used to transform a list by some function or to fold a list by some combine function and a base case into a single object
\1 Partial functions with option types are those which do not always find a value, used for those that require specific inputs to return a proper output, using an option type to return a null option if no value is possible, and a value storage option otherwise
\end{outline*}
\section{Modularity and Abstraction}
\begin{outline*}
\1 Abstract types are those which bundle the operations and type name with an interface for the functions by which it can be used, but do not allow direct access to the implementation/proper function codes
	\2 Modules are independently compilable collections of code, containing abstract data types and their functions, which when providing common data structures or algorithms, are called libraries
		\3 These are accessed either by ``;; open $<Module>$'' or by using dot notation for any identifiers given by the module ($<Module>.<Id>$)
	\2 Interfaces are created either in an mli file type or a module type signature, the former written by the type name, followed by each function written by ``val $<functName> : <input1> -> <input2> -> <output>$'', where val is used to denote an expected value
		\3 Module type signatures are written inside an ml file by ``module type $<typeName> = sig <typeInterface>$ end'', with the interface written as in an mli file
		\3 The implementation can be written as a module of the interface as a nonabstract type, by ``module $<typeName> : <AbstractTypeName> = struct <typeImplementation>$ end'', called an explicitly named module
			\4 In this case, the ml file in which they are defined must be opened, after which dot notation must be used for each type, rather than either
	\2 For each implementation, OCaml checks if it fully complies with the interface, implementing all expected functions, though it is able to have additional ones
\1 Abstract types are useful for not showing the specific usage of implementation, allowing any particular means of implementing, using some implementation type combined with an invarient/rule to preserve the type properties
	\2 Each choice of representation and invariant has respective advantages and disadvantages in terms of time optimization
\end{outline*}
\section{Unit and Sequencing Commands}
\begin{outline*}
\1 Functions are able to take or return unit variables in cases in which the parameter/return type are irrelevent, used by commands to represent the external effect produced
	\2 Thus, ``print\_string'' and other similar commands return a unit type
\1 Commands can be embeded in an expression using a single operator, ``;'', between the command and the next portion of the expression, returning a unit value which is ignored, but which may have side effects within the program
	\2 As a result, the semicolon is always used as a separator, rather than as a terminator like in many other languages, seperating commands, fields, elements, or running top-level commands
\end{outline*}
\section{Mutability and Abstract Stack Machine}
\begin{outline*}
\1 Records assign names to specific values, such that they is defined by ``type $<name>$ = \{$<name1>:<type1>; ...$<nameN> = <valN>$;\}$'', with records written by ``let $<var>: <name> = \{<name1> = <val1>$; ...$<nameN> = <valN>$\}''
	\2 Values are accessed by ``$<var>.<nameNumber>$'', able to be changed slightly in a new variable by ``let $<newVar> = \{<var> with <nameNumber1>=<valNumber1>; ...\}$''
	\2 Existing records can be copied and modified by ``\{$<oldRecord> with <nameNumberN> = <valNumberN>$\}''
\1 Mutable data are those which are able to be properly changed, rather than shadowed, destroying the original data, called imperative programming rather than pure programming, allowing aspects of the program to share data elements
	\2 Mutable records are defined by ``type $<name> = \{mutable <name1> : <type1>\}$'', able to be defined outside of a function as a global variable
	\2 These are changed by ``$<var> <- <newVal>$;'', acting as a command returning a unit
	\2 Due to mutable values being shared by functions, multiple variables are able to point to the same data structures, called aliasing, destroying the substitution programming simplification method
	\2 Programs using mutable data are refeerred to as imperative programming, while those that don't are pure programming
\1 The Abstract Stack Machine is an alternative to the substitution model, accounting for the location of data in the computer memory, assuming the language is type-safe and garbage-collected, such as OCaml or Java
	\2 It is made up of the workspace to keep track of the expression currently being evalutated, the stack for bindings, primitive values, and partially simplified expressions, and the heap is for data structures
		\3 Bindings are made up of an identifier and a reference to an address/location of a piece of data, denoted by an arrow
			\4 References are abstract locations, not having a specific value within the computer, while pointers are the specific reference location value
		\3 The heap contains cells (labelled data types with possible parameters/references), records (containing a table with the variables on the left, the values double boxed on the right), and anonymous functions
	\2 The ASM begins with an empty stack and heap, finding the left-most ready expression within the workspace to simplify, adding to the stack and heap as it moves along, removing those expressions from the workspace
		\3 Each value is added below previous values in the stack, using the most recent value within the stack at a given time to display shadowing
		\3 The stack functions by popping out all elements from the bottom as it leaves the scope, such that it follows the LIFO procedure
		\3 The evaluation of the expression is complete when the result is the remaining item in the workspace
		\3 Function definitions are converted to an anonymous function with a binding, the binding put in the stack, and the anonymous function placed in the heap
	\2 Functions are simplified by adding the outside layer of the function into the stack with a space inside for the result of the inner layers, changing the inner layer into the new workspace, evaluating, then bringing it back to the workspace and popping off the stack for the inner layer
		\3 The space inside the outer function layer is denoted by ``(\_\_\_)''
	\2 Aliases are denoted by references in the stack to the same object in the heap, tested by the reference equality operator ``=='', rather than the structural equality ``=''
		\3 For primitive values, since they are only in the stack, the reference equality operator returns true if the structural equality operator does
\1 Options are denoted about the value with an arrow at the top left corner, while a slash through the reference box implies it links to a None option
\end{outline*}
\section{Queues/Linked Structures}
\begin{outline*}
\1 Linked structures are made out of a data block attached to other data blocks in some sequence with some set of operations able to act on it
	\2 Queues are structures with the function enqueue to add to the tail, and dequeue to remove from the head, with last in, last out (LILO) usage, with each node made up of a value and a mutable option link to the next value
	\2 The queue also contains a link to the first and last non-zero elements within the queue
\1 The Queue Invariant states that either the head and tail must both be None, or for the head as Some n1 and the tail as Some n2, n2 is reachable by following next pointers from n1 and n2.next is None
	\2 As a result, the same node is not able to be in the queue more than once as an alias, due to violating the invariant by creating a cycle
\1 Mutable structures can be evaluated by a loop helper function defined within the overall function, either by recursion or by tail call optimization
	\2 Tail call optimization saves space by modifying recursion into iteration, emptying the workspace of the previous function call fully before calling it again, such that the bindings can be removed from the stack
		\3 As a result, the final call within the recursive function is the calling of it again, having fully evaluated the previous call, using an accumulation argument to preserve values from previous calls
	\2 This provides more risk of undetected infinite loops, due to not causing a stack overflow, either by not iterating through the structure or iterating through a cycle
\end{outline*}
\section{Local State/Objects}
\begin{outline*}
\1 Local states are states packaged with several functions that operate on it, shared mutably between the functions, unable to be modified outside of those functions, used to avoid the need for many global states
	\2 Rather than a global record to keep track of a state, there is a function producing a new record each time it is run, returning a function to increment that counter
	\2 This is accomplished by the ASM storing the function, along with any local stack bindings needed to evaluate it, to the heap, such that the counter isn't on the stack, but is readded by the function immediately when called, even before arguments are added to the stack
	\2 The combination of a function and locally stored bindings is called a closure, with the localization of the state being called encapsulation, restricting access to the data to the specifically designated functions
		\3 Multiple objects are also able to be tied to the same data, to allow separation between the modification functions and the usage functions
\1 Objects are created by making a record of several functions, and a creation function that produces a state record modified by the function records
	\2 This is made easier by the 'a ref (reference) type, used as shorthand for a record with a single mutable field called contents, with the ! operator to provide the contents, and the := operator to redefine the contents
\end{outline*}
\section{OCaml GUI Library}
\begin{outline*}
\1 GUIs use an event-driven model of reactive programming, reacting to user-caused events, such as mouse or keyboard input
	\2 OCaml uses the event type, as a record to indicate the status of keys, the mouse button, and the mouse location
\1 The OCaml graphic library is used by adding the ``graphics.cma'' compiler flag, providing functions such as open\_graph (to open a new window), clear\_graph (to erase the window), resize\_window (to set the window size), size\_x (to return the width), and size\_y (to return the height)
	\2 It also provides the type color, as a record with items r, g, and b, with various predefined colors
	\2 It also contains a pen with functions set\_color, move\_to, and (plot x y) to color the pixel with the current pen color, as well as (line\_to x y) (from the current location) and functions for other shapes drawn
	\2 The graphics library uses double buffering, modifying a hidden second copy of the window, pushing that into the main window and erasing, instead of modifying the main window directly to prevent flickering
\1 GUI libraries are generally made with built-in buttons and textboxes, as well as systems for positioning relative components of the GUI, to avoid precarious global window coordinate systems
	 \2 Widgets are made such that they generate themselves using a widget-local coordinate system, with the left upper corner as the origin, offset by the main window
	 	\3 As a result, there is the Gctx module used to draw the widget, with the gctx type including the color and location, used to get the offset, all from the upper left hand corner, as well as including methods to convert from coordinate systems
	 		\4 Gctx also has functions used to draw different objects
	 	\3 The OCaml graphics library has the origin at the lower left corner, rather than the upper, which is non-ideal for a GUI, due to adding space to the bottom, rather than the top
	 \2 The widget module is a closure containing a repaint function (using a gctx coordinate) and a size function, including a space widget, a label widget, a canvas (parameterized drawing) widget, and a border widget (taking another as a parameter)
	 	\3 The hpair function is used to pair two widgets into a single widget, aligned at the top, equally next to each other, and a border widget, padding the outside of a widget into a larger widget, connected to the original widgets
	 	\3 This allows forming a widget tree to create a complete widget appearance, generating a complete widget, with the base as the highest level/toplevel
\1 GUIs are generated by creating an infinite loop run function, repainting the entire GUI with any changes constantly, waiting for an event, then called the handle function of the root widget
	\2 Event types are mouse drags, moves, up, and down (returning the type and position), as well as key presses (returning the character pressed)
	\2 Event handlers of a widget take in the graphics state (gctx) and the event, routing through the widget tree to the final widget
		\3 Notifier widgets are used to check for events, keeping a list of event listeners, sending the event to each event listener, which in turn performs an action function if the event is detected
	\2 Widgets which have states also have controller objects to control the state, routing to the same local state
		\3 The controller object might also have a list of change listeners, modifying those values based on the new object value
\end{outline*}
\section{Introduction to Java}
\begin{outline*}
\1 Programming is divided into functional (with immutable data structures and recursion), imperative (with mutable and iterative), and object-oriented/reactive (with abstraction and encapsulation)
	\2 Java is superior at the last, equal with OCaml at the second, and the worst at the first, while OCaml is the reverse
	\2 Java objects combine the local state, method definitions, and instantiation into a single construct, called a class, made up of fields (instance variables), constructors, and methods (member functions)
		\3 The keyword public makes the class globally available, while the keyword private means it can only be accessed by code within the class itself, such that fields are generally private, while classes are public, methods either
		\3 Methods within Java are declared by ``$<permission> <returnType> <name> (<type1> <param1>, ...) {<Code>}$''
		\3 New variables of a class are created by ``$<className> <var> = new <initializer>;$''
	\2 The main function in Java is stored within a class, with the definition ``public static void main(String[] args)''
		\3 Void is used similarly to unit, to denote the lack of a return value
\1 Java is a statement language, made up of a series of commands executing, each ended by ;, with conditional statements reducing to a statement
	\2 Java contains the null value to imply the lack of a reference, automatically assigned to a variable, such that attempts to evaluate return a NullPointerException, instead of the option type
	\2 Unlike OCaml, all variables are mutable by default, able to be redefined with equals
	\2 Interfaces in Java, similar to OCaml, are defined by the header ``public interface $<intName>$ \{\}'', containing the headers for each function, without any constructors or fields
		\3 It is used by adding ``implements $<intName>$'' after the name of the class
		\3 Since interfaces can render the specified implementation unknown until the program is running, Java uses dydnamic dispatch to provide the function mode based on the dynamic class stored in the interface object
			\4 On the other hand, static methods can be used for those that are associated with the class, rather than the object, able to be evaluated at compilation, thus only able to reference other static methods and fields of the class
			\4 Static methods are called by ``$<className>.<methodName>()$'', not requiring producing an object instance to use
			\4 Static is also able to be used to provide fixed values to a field within a class, given a value outside of the constructor automatically
\1 Java contains primitive types of int, byte, short, long (integer types), char, float, double (floating point types), and boolean, using overloaded operators such that the same operator can act on multiple types
	\2 Referential equality is denoted by ==, while structural equality is determined by the .equals() method
	\2 Logical not in Java is denoted by ``!'', logical and as ``\&\&'', logical or as ``||'', modulus as ``\%'', and inequality as ``!=''
\1 Java identifiers are stored in different namespaces for classes, fields, methods, and local variables, such that the same identifier can be used for different types of items, though this can produce confusion and should be avoided
\1 Java has arrays, or sequentially ordered collections of elements indexed with integer positions, accessed in constant time, denoted by ``$<type>$[]'', with each element found by ``$<name>[i]$'', with the field name.length to provide the size of the array
	\2 Attempting to access a value out of bounds gives the ArrayIndexOutOfBoundsException, starting from 0 going to name.length - 1
	\2 Array elements are automatically mutable in Java, such that they can be redefined, initialized for any object or type by ``$<type>$[] $<name>$ = new $<type>$[$<length>$];''
		\3 They are also able to be declared statically instead of initializing by a list of comma-seperated objects within curly brackets, done at the time of declration
		\3 Arrays require predetermination of the size, such that the name is a reference to the location on the heap
	\2 Multidimensional arrays are noted to possibly not be in order, with only the references to each inner array in an order in the outer array, and the inner arrays in order by themselves, denoted as the inner having the row number of items, the other of the column number of arrays
		\3 It is noted that the inner arrays can be declared independently (or statically), such that they may not be the same length
\1 The Java Abstract Stack Machine is different from OCaml in that almost all variables are mutable, the heap only contains arrays and objects, rather than other data types, it has the null reference, and methods and constructors are stored outside the three components, called a class table
	\2 The length of an array is never mutable, while other fields may or may not be (marked with a thick black box), with the array elements just stored in order
\1 Java methods are said to encapsulate an object state if there is no possible way to violate the invarients of an object, due to keeping fields private
	\2 It is noted that unlike OCaml, an interface does not contain the constructor signature for an object of the class, due to only existing in the implementation
\end{outline*}
\section{Subtyping, Extension, and Inheritance}
\begin{outline*}
\1 Types are used to restrain interaction between parts of code, such that Java is strongly typed, each expression given a type, using objects of a type, built from a class
	\2 Interfaces are considered to allow subtyping, with each class as a subtype of the interfacts it implements, able to be declared for the supertype, only using functions from the supertype
	\2 Classes are able to implement multiple interfaces, seperated by a comma, satisfying the method requirements of both
		\3 In addition, interfaces themselves are allowed to extend or inherit from another interface, and a class can extend or inherit from another, gaining the methods of its supertype
			\4 Interfaces are able to inherit from another interface by the ``extends'' keyword, gaining any methods from the higher interface, allowing it to be fit in a variable of either the interface, or the extension
			\4 Inheritance allows classes to gain the fields and methods of its superclass by the ``extends'' keyword, though each may only have a single superclass, though able to have many subclasses, able to be placed in a variable of itself or any level of superclass
			\4 Private fields in a superclass are unable to be accessed within methods of the subclass, except if the ``protected'' keyword is used instead
		\3 Since constructors require the class name, they are unable to be inherited, but is allowed to access the superclass's private fields by the function, super($<params>$), acting to call the superclass constructor within the subclass constructor
			\4 This is noted to be required to be the first line within the constructor
	\2 The compiler is only able to see the type declared for a variable, such that it isn't allowed to be used as the actual object type, but only as the variable type
		\3 As a result, the variable type is static, while the class itself is dynamic, such that the type restricts how the class is used and provides the expression with a type
		\3 Similarly, the dynamic class determines which particular methods are used during runtime, with a single type for each memory block, unlike the static type which may have multiple possibilities for each object
\1 The highest Java class is called the Object call, automatically extended by every class without a superclass, acting as the root of the class tree
	\2 The Object class provides the toString method and the equals method automatically to every class
\end{outline*}
\section{Dynamic Methods in the ASM}
\begin{outline*}
\1 Dynamic dispatch is used to show the normal method calls and constructors, controlled by the dynamic class, rather than the static type
	\2 The class table is the fourth component, acting as a tree, with extends fields linking to the superclass, and containing the methods and constructors of the class
		\3 Methods are able to reference the class that called them by the ``this'' keyword, implied in every field access, such that the workplace modifies the code to make it explicit
		\3 In addition, ``super()'' is made explicit at the start of the constructor by the workspace as well, such that there must be a default constructor unless a parameterized super constructor is used
		\3 Static values are stored within the class table as well, called purely by the class name rather than a specific object
	\2 When the constructor is called it allocates the object onto the heap, creating space for all fields and setting the default values (0 for numbers, null for references), having saved the remainder of the workspace on the stack, taking the function from the class table
		\3 A pointer is then created for the class, called the dynamic type of the object, creating a ``this'' field on the stack, attached to it
			\4 As a result, the main difference between a static and dynamic method is the lack of a ``this'' pointer to allow access to nonstatic methods and fields
		\3 It is noted that on the heap, the object is given the dynamic class as a point of information
	\2 Similarly, dynamic method calls create a ``this'' reference, while using dynamic dispatch to find the correct method, searching the class table upward with the class table pointers
\1 It is noted that while methods of a subclass cannot modify the private fields of a superclass, the inherited methods from the superclass are able to
\end{outline*}
\section{Generics, Collections, and Iteration}
\begin{outline*}
\1 Libraries are useful due to the premade abstraction, such that it is a skill to be able to read the documentation and use the abstraction efficiently, as well as to be able to design functional libraries
\1 Polymorphism allows functions to take different argument types, contained in Java by subtype polymorphism (using a supertype variable) and generics/parametric polymorphism, the latter ideal for container data types
	\2 Generics are used adding ``\textit{ObjectName}$<E>$'', after which E is used as the type, declaring the object variable itself by specifying the E type by similar notation
		\3 This allows specific objects to be returned, rather than generalized static types, allowing easier usage, though it limits the type allowed for each object instance (able to be regeneralized by setting E as Object)
	\2 Generic types must have the type parameter as invarient, such that if type A is a subtype of type B, if A is the parameter for one object and B for another, the former is not a subtype of the latter
\1 The Java Collections Framework contains List, Deques, and Sets interfaces, each with a generic, under the Collection$<E>$ interface, as well a finite map interface with $<K, V>$ (key, value) generics
	\2 It is noted that the contains and remove functions both use Object, rather than E, due to the equals function of a specific class not necessarily returning false for different classes of objects
	\2 ArrayList<E> and ArrayDeque<E> stem from List<E> and Deque<E> respectively, while LinkedList<E> stems from both, as the three main sequence implementations
		\3 ArrayList and LinkedList allow accessing by position, the former in an array, such that it is equally fast to access any item, while in LinkedList, it is faster to add items into the middle
	\2 Set has HashSet stemming from it, as well as the SortedSet interface, from which TreeSet stems, while Map has HashMap and SortedMap, based off of hashing and binary search trees respectively
	\2 $Collection<E>$ extends $Iterable<E>$, requiring an iterator method giving an $Iterator<E>$ object, the object checking if there is another item in the list, providing the next item, and eleting an item
		\3 The iterator allows abstraction of traversing a collection, regardless of the collection implementation
		\3 This can be made easier for any Iterable by the for-each loop, written ``for(Type TypeVariable : IterableVariable) {...}'', automatically iterating for each item in the iterable
			\4 It is noted as well that arrays are iterable in Java, such that the for-each and iterator methods are usable
\end{outline*}
\section{Overriding and Equality}
\begin{outline*}
\1 Method overriding is the idea of a subclass redefining a superclass method, utilized by dynamic dispatch methods
	\2 It is noted that dynamic dispatch controls every single method invocation, such that even if it is called within a superclass method, dynamic dispatch still begins again from the dynamic class
	\2 As a result, each superclass must account for the implementations of the subclass, such that the behavior of any overriden methods still aligns with the superclass functions
		\3 Thus, it is generally used only if both classes are from the same author, or the parent class is made for overriding
		\3 Composition and delegation can often be used as a substitute for method overriding
	\2 The ``final'' keyword can prevent overriding of a method by a subclass
\1 The equals method generally has to be overriden by subclasses, or it can return that objects are structurally equal at incorrect times
	\2 It has to be overriden when the class represents immutable values, such that there is a distinct set of states, such as coordinates or strings
	\2 The method creates an equivalence relation on non-null objects, such that it is reflexive (returns true when on itself), symmetric, transitive, consistant, and ``x.equals(null)'' must return false
		\3 The symmetric property can cause issues when an object of the superclass and subclass are compared, fixed by ensuring they are of the same dynamic class
	\2 It is noted that by default, it is overloaded, rather than overridden, such that the superclass method is still present
		\3 It can be overrided by the ``@Override'' tag before the method
		\3 The ``$<var>$ instanceof $<Class>$'' command returns a boolean determining if dynamic typecasting to a more specific variable is allowed
		\3 The dynamic class of an object can also be accessed by the getClass() function, which returns an Class$<dynamicClass>$, such that it is referentially equal for objects of the same classs
	\2 Equals methods also often check for referential equality to provide a shortcut on the method if they are referencial
	\2 The ``super.$<fun>()$'' keyword can also be used to call the superclass function, even if it has been overridden
\end{outline*}
\section{Exceptions}
\begin{outline*}
\1 Exceptions are necessary for incorrect inputs, optional interface methods when they are not found in a particular implementation, incomplete softwarre, or overflows
	\2 Failures can be dealt with by returning an error value, an option call, or an exception (ending the program and decribing the error)
	\2 Exceptions in Java are objects in a subclass of the Exception class, thrown by the ``throw'' keyword when there is an error, ending the program
		\3 Exceptions can also be caught by a ``try {...} catch($<ExceptionType>$ e) {...}'', such that instead of ending the program, the program can respond to the exception
			\4 Multiple catch blocks are allowed to check for each type of exception, skipping the remainder
			\4 It is generally bad to have too generalized catches, because that can hide unexpected exceptions
			\4 Try-catch blocks can also have a ``finally {...}'' block at the end, always running after the try and catch blocks, regardless of if anything was caught or not
		\3 Constructors are unable to return null, such that the only way to show an error is to produce an exception
		\3 Exceptions are dealt with in the stack machine by putting the catch handler on the stack when the try portion is called, such that when the exception is found, the stack is popped until catch is found, ending the program if emptied
\1 Exceptions are a subclass of the Throwable object, while Error objects are subclasses of the Throwable as well, the latter unable to be caught, purely for fatal errors
	\2 Exception objects are divided into subclasses of IOException and RuntimeException
		\3 IOExceptions must be declared in the header of both the method itself and the interface method by ``throws $<ExceptionType>$'', while RuntimeExceptions do not need to be
		\3 Methods that call methods that may throw an IOException also must declare the exception throwing in the header
		\3 If the method catches the exception, it does not need to declare the exception
	\2 RuntimeException classes include NullPointerException, IndexOutOfBoundsException, and IllegalArgumentException, not necessary to declare due to the commonality
	\2 User-created exception classes are necessary to declare if they are not a subset of the RuntimeException class
\1 Declared exceptions are more difficult to adapt to new code, but are more noticable to the coder due to being explicit, generally only used for very general libraries
	\2 Catch blocks are also supposed to be present as close to the throwing of the error as possible
	\2 It is also often good to catch more generalized exceptions and rethrow more specific, user-defined exceptions as a replacement
\end{outline*}
\section{IO in Java}
\begin{outline*}
\1 Java abstracts IO by steams, acting as a sequence of values in order, possibly without a specific end, either as an input or output stream, feeding values individually
	\2 The InputStream abstract class has a read() method to return the next byte of data, throwing an IOException if it cannot be read, returning a -1 at the end of the stream
	\2 The OutputStream abstract class has a write(int i) method to write a byte of data, throwing an IOException if it cannot be written
	\2 Both abstract methods are limited to values from 0 - 255, or bytes, and are abstract such that subclasses must implement the methods
\1 FileInputStream and FileOutputStream extend the abstract classes to allow reading and writing binary data, using the function close() to end the file stream, constructed with the filename as the parameter
	\2 Similarly, BufferedInputStream and BufferedOutputStream is a wrapper, constructed with the file stream as a parameter, allowing input and output of groups of characters at once to save time
\1 The PrintStream class extends OutputStream, used to print different functions, such that the static field ``System.out'' contains an instance of the class, using the overloaded println method to print various values
	\2 It also contains the ``print(String)'' function to print a string into the stream without flushing or ending the line, and the flush() function to flush the buffer
	\2 The buffer is automatically implemented by the PrintStream for the output, and flushed at newlines or when full
\1 The Reader and Writer abstract classes are used for streams of characters (16 bits), similar to the byte Input/OutputStream classes, returning -1 when the stream is finished, constructed similarly
	\2 There are also cooresponding FileReader/FileWriter and BufferedReader/BufferedWriter wrappers for these classes as well
	\2 Since Strings are immutable, each character would have to be appended to the String, unless the length was previously known, such that it would be slow
		\3 The StringWriter class produces a resizable array, doubling the array when filled, able to be written quicker, and then converted by toString()
\end{outline*}
\section{Swing/Java Graphics Library}
\begin{outline*}
\1 Swing is an event-based, object-oriented, Java graphics library, functioning similarly to the OCaml Graphics Library, fundamentally made up of JComponent widgets
	\2 The main JComponent methods are the ``void paintComponent(Graphics g)'', where Graphics is the graphic context class for the program, and ``Dimension getPreferredSize()'' methods
		\3 Unlike OCaml, Java Swing only repaints the window when necessary and commanded to do so, instead of calling it in each step/tick
	\2 The coordinate system is relative to the upper left corner of the JComponent being used
	\2 Swing applications are begun by the command ``SwingUtilities.invokeLater(new DrawingApplication());''
\1 JComponents are stored within other JComponents, with the highest level stored within a JFrame, which produces the window itself through the operating system, with the argument as the title of the window
	\2 The JFrame is run by an object that implements the Runnable interface, required to have a ``public void run()'' method
	\2 This contains a JFrame, initialized with a string to give the window a title, able to add components to the frame by the add() method
		\3 The command ``$<frameName>$.setDefaultCloseOperation(JFrame.EXIT\_ON\_CLOSE);'' is used to make the application close when the frame does
		\3 ``$<frameName>.pack()$'' is used to resize the frame based on the components automatically
		\3 The ``$<frameName>.setVisible(true);$'' command makes the frame appear on the screen properly, by the OS
	\2 JPanels are used to store multiple components together, defaulting horizontally, adding the components from left to right
\1 The ActionListener interface is used with the method ``public void actionPerformed(ActionEvent e)'', able to be added by the ``addActionListener(ActionListener e)'' method of various components
\1 The Timer class is used to measure the time between updates, creating an action after every given amount of time after started by ``$<timerName>.start()$''
	\2 It is constructed by ``new Timer($<msBtwUpdate>, <EventListener>$);''
\end{outline*}
\section{Homework Notes}
\begin{outline*}
\1 No multi command conditionals?
\1 In needed for complex functions?
\1 Can't create an empty user-defined datatype, accessed by begin match similar to regular types (Node (a, b) ->, etc)
\1 Need either variable or wildcard
\1 When can you use multiple lines in a single begin match command?
\1 Type is not properly implemented in interface, though a function for an empty can be, since functions are values in OCaml
\1 Equals checks if the structure is identical, in addition to the data for any object

\1 Dot library notation can be used rather than including the library directly
\1 End of a unit function has no ;, and returns nothing
\1 Commands can be used to throw away a function result

\1 Cannot call other Java constructor for same class within constructor

\1 Arrays are stored within the heap in OCaml
	\2 The Some option is denoted with a bubble at the end of the arrow
	\2 Some/None must be typechecked for, and are noted to not be referentially the same if declared in seperate places, even with the same internal
\end{outline*}
\end{document}